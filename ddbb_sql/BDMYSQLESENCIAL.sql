
USE compras;
-- INSERT
INSERT INTO CATEGORIA (nombre, descripcion) VALUES ('Cereales', 'Productos maíz, trigo, arroz, avena,...');
SELECT * FROM CATEGORIA; 
DESCRIBE CATEGORIA;
SELECT * FROM PRODUCTO;
DESCRIBE PRODUCTO;

SELECT NOMBRE, PRECIOUNITARIO FROM PRODUCTO;
SELECT * FROM EMPLEADO WHERE SALARIO > 500;
SELECT * FROM EMPLEADO WHERE IDEMPLEADO = '1';

SELECT * FROM CLIENTE WHERE PAIS = 'Canadá';

SELECT * FROM PRODUCTO WHERE IDCATEGORIA = '5';
SELECT * FROM PRODUCTO WHERE IDCATEGORIA = '7';

-- Si introducimos información incorrecta en las tablas, podemos actualizar información una vez esté almacenada

SELECT * FROM EMPLEADO;
DESCRIBE EMPLEADO;

-- Actualizaremos la información de email de un empleado

UPDATE EMPLEADO SET EMAIL = 'alicia@enelpaisdelasmaravillas.com' WHERE IDEMPLEADO = '3';
SELECT * FROM EMPLEADO WHERE IDEMPLEADO = '3';
UPDATE EMPLEADO SET EMAIL = 'alicia@ejemplo.com' WHERE IDEMPLEADO = '3';


-- Elmiminar datos

DELETE FROM EMPLEADO WHERE IDEMPLEADO = '5'; 

-- Error Code: 1451. Cannot delete or update a parent row: a foreign key constraint fails (`tienda1`.`factura`, CONSTRAINT `FK_REL_EMP_FAC` FOREIGN KEY (`idEmpleado`) REFERENCES `empleado` (`idEmpleado`) ON DELETE RESTRICT ON UPDATE CASCADE)
SELECT * FROM FACTURA;
-- El cliente cuyo IDEMPLEADO = 5 tiene dos facturas asociadas, el error que nos muestra es de integridad referencial.
SELECT * FROM EMPLEADO;

-- OPERADORES LÓGICOS --- 
SELECT * FROM PRODUCTO;

SELECT IDPRODUCTO, NOMBRE FROM PRODUCTO WHERE PRECIOUNITARIO < 2.30 AND IDCATEGORIA = 2;

SELECT IDPRODUCTO, NOMBRE FROM PRODUCTO WHERE PRECIOUNITARIO < 2.30 OR IDCATEGORIA = 2;

SELECT * FROM PRODUCTO WHERE IDCATEGORIA != 2;

SELECT * FROM PRODUCTO WHERE IDCATEGORIA IS NOT NULL;

-- Devuelve los registros que no cumplan con ambas condiciones.
SELECT * FROM PRODUCTO WHERE PRECIOUNITARIO < 2.30 XOR IDCATEGORIA = 2;

-- OPERADORES DE COMPARACIÓN ---

SELECT * FROM EMPLEADO WHERE SALARIO > 500;

SELECT * FROM EMPLEADO WHERE SALARIO < 500;

SELECT * FROM EMPLEADO WHERE SALARIO >= 500;

SELECT * FROM EMPLEADO WHERE SALARIO = 500;

SELECT * FROM EMPLEADO WHERE SALARIO <> 500;

-- SELECCIÓN DE RANGOS ---

SELECT * FROM EMPLEADO WHERE SALARIO BETWEEN 500 AND 700;

SELECT * FROM EMPLEADO WHERE FECHAINGRESO BETWEEN '2018-01-20' AND '2018-12-31';

SELECT * FROM EMPLEADO WHERE SALARIO NOT BETWEEN 500 AND 700;

SELECT * FROM EMPLEADO WHERE FECHAINGRESO NOT BETWEEN '2018-01-20' AND '2018-12-31';

-- Seleccionar a varios elementos de una lista

SELECT * FROM FACTURA WHERE IDFACTURA = 1 OR IDFACTURA = 3 OR IDFACTURA = 5 OR IDFACTURA = 7;

SELECT * FROM FACTURA WHERE IDFACTURA != 1 AND IDFACTURA != 3 AND IDFACTURA != 5 AND IDFACTURA != 7;

-- Existe otra forma abreviada de hacer esto mismo.

SELECT * FROM FACTURA WHERE IDFACTURA IN (1, 3, 5, 7);

SELECT * FROM FACTURA WHERE IDFACTURA NOT IN (1, 3, 5, 7);

-- MANEJO DE VALORES NULOS ---

SELECT * FROM CLIENTE WHERE TELEFONO IS NOT NULL;
-- Puede ocurrir que se tenga un espacio en blanco... no es lo mismo que NULL

SELECT * FROM CLIENTE WHERE TELEFONO IS NULL;

SELECT * FROM CLIENTE WHERE ISNULL (TELEFONO);

-- MANEJO DE PATRONES ---

SELECT * FROM PRODUCTO WHERE NOMBRE LIKE 'Avena';

SELECT * FROM PRODUCTO WHERE NOMBRE NOT LIKE 'Avena';

SELECT * FROM PRODUCTO WHERE NOMBRE LIKE 'Aven_';

SELECT * FROM PRODUCTO WHERE NOMBRE NOT LIKE 'Aven_';

SELECT * FROM PRODUCTO WHERE NOMBRE LIKE '%A%e%a%';

SELECT * FROM PRODUCTO WHERE NOMBRE NOT LIKE '%A%e%a%';

SELECT * FROM PRODUCTO WHERE NOMBRE LIKE 'A%';

SELECT * FROM PRODUCTO WHERE NOMBRE NOT LIKE 'A%';

-- OPERADORES ARITMÉTICOS ---

SELECT * FROM DETALLE_FACTURA;

SELECT IDPRODUCTO, PRECIOUNITARIO * CANTIDAD AS TOTAL FROM DETALLE_FACTURA;

SELECT IDPRODUCTO, (PRECIOUNITARIO * CANTIDAD) - (PRECIOUNITARIO * CANTIDAD * 0.10) AS 'PRECIO CON DESCUENTO' FROM DETALLE_FACTURA;


-- FUNCIONES DE FECHA Y HORA ---

SELECT CURDATE();
SELECT NOW();
SELECT LOCALTIME();
SELECT LOCALTIMESTAMP();

-- Vamos a convertir un string a un formato fecha

SELECT STR_TO_DATE('22 Nov, 2020', '%d %M, %Y');

SELECT DATE('2020-11-22 14:11:00') AS FECHA;

SELECT NOW();

SELECT DATE(NOW()) AS FECHA;

SELECT DATEDIFF('2020-11-20', '2020-11-23');

SELECT * FROM EMPLEADO;

SELECT NOMBRE, FLOOR(DATEDIFF(NOW(), FECHANACIMIENTO)/365) AS AÑOS FROM EMPLEADO;

SELECT DATE_ADD(NOW(), INTERVAL 10 DAY) AS FECHA; 

SELECT DATE_ADD(NOW(), INTERVAL -10 DAY) AS FECHA; 

SELECT DATE_ADD(NOW(), INTERVAL -10 YEAR) AS FECHA;

SELECT EXTRACT(YEAR FROM NOW()) AS AÑO;

SELECT EXTRACT(DAY FROM NOW()) AS DAY, EXTRACT(MONTH FROM NOW()) AS MES;

SELECT * FROM EMPLEADO;

SELECT NOMBRE, DATE_FORMAT(FECHANACIMIENTO, '%a, %b %Y') AS 'FECHA NACIMIENTO' FROM EMPLEADO;

-- https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-format 

-- OTRAS FUNCIONES --- 

SELECT ABS(-6);
-- Redondeo hacia arriba.
SELECT CEIL(9.75);
-- Parte entera
SELECT FLOOR(9.95);
-- Resto de la división entera
SELECT MOD(19, 5);

SELECT PI();

SELECT POWER(3,2);
-- Devuelve valor aleatorio [0, 1]
SELECT RAND();
-- Redondeo hacia arriba a partir del .5
SELECT ROUND(16.5);

-- Mostrar la cantidad de decimales que indiquemos
SELECT TRUNCATE(5.432, 2);

-- https://dev.mysql.com/doc/refman/8.0/en/

-- CADENAS DE CARACTERES ---

SELECT * FROM EMPLEADO;

SELECT CONCAT(NOMBRE, ' ', APELLIDO) AS NOMBRE FROM EMPLEADO;

SELECT CONCAT_WS(' ', NOMBRE, APELLIDO) FROM EMPLEADO;

SELECT * FROM PRODUCTO;
SELECT INSTR(NOMBRE, 'N') AS POSICION FROM PRODUCTO WHERE IDPRODUCTO = 1;

SELECT NOMBRE, LENGTH(NOMBRE) AS LONGITUD FROM PRODUCTO;
SELECT * FROM PRODUCTO;

SELECT REPLACE(NOMBRE, 'Jugo', 'Extracto') AS NOMBRE FROM PRODUCTO WHERE IDPRODUCTO = 11;
SELECT * FROM EMPLEADO;

SELECT REVERSE(NOMBRE) AS INVERSO FROM PRODUCTO; 
SELECT SUBSTRING(NOMBRE, 9) AS SUBCADENA FROM PRODUCTO WHERE IDPRODUCTO = 11;
SELECT SUBSTRING(NOMBRE, 9, 3) AS SUBCADENA FROM PRODUCTO WHERE IDPRODUCTO = 11;

SELECT LTRIM('   Texto con espacios');
SELECT RTRIM('Texto con espacios    ');
SELECT TRIM('   Texto con espacios    ');

SELECT LOWER(NOMBRE) FROM PRODUCTO;
SELECT UPPER(NOMBRE) FROM PRODUCTO;

SELECT * FROM EMPLEADO;
SELECT NOMBRE, CAST(FECHAINGRESO AS DATETIME) FROM EMPLEADO;

SELECT CAST(NOW() AS DATE);

SELECT NOMBRE, CAST(SALARIO AS CHAR) AS TEXTO FROM EMPLEADO;
SELECT CONVERT('20201201', DATE) AS DATE;

-- Funciones de encriptación en SQL. 
-- Es necesario entrar en Edit / Preferences / SQL Execution / Marcar Treat BINARY para que aparezca en formato encriptado y no BLOB---
-- MICONTRASEÑA es el texto a cifrar y descifrar ---
SELECT AES_ENCRYPT('MICONTRASEÑA', 'KEY'); 
SELECT AES_DECRYPT(AES_ENCRYPT('MICONTRASEÑA', 'KEY'), 'KEY');

-- https://dev.mysql.com/doc/refman/8.0/en/encryption-functions.html 

-- Cadenas encriptadas ---
SELECT MD5('MICONTRASEÑA');
SELECT SHA('MICONTRASEÑA');
-- 224, 256, 512... bits de cifrado.
SELECT SHA2('MICONTRASEÑA', 224	);

-- FUNCIONES DE INFORMACIÓN EN MYSQL ---

SELECT DATABASE();
SELECT USER();
SELECT VERSION();
SELECT * FROM CLIENTE;
SELECT FOUND_ROWS();

-- Insertamos un nuevo producto ---

INSERT INTO PRODUCTO(NOMBRE, IDCATEGORIA, PRECIOUNITARIO) VALUES ('Arroz a granel', '2', '4');
SELECT * FROM PRODUCTO;
SELECT LAST_INSERT_ID();

INSERT INTO PRODUCTO(NOMBRE, IDCATEGORIA, PRECIOUNITARIO) VALUES ('Ciruela', '6', '2');
SELECT ROW_COUNT();
SELECT * FROM PRODUCTO;


-- AGRUPACIÓN, ORDENAMIENTO Y LÍMITES ---

SELECT * FROM DETALLE_FACTURA;
-- Vamos a ver la totalidad de productos vendidos
SELECT SUM(CANTIDAD) AS TOTAL FROM DETALLE_FACTURA;
SELECT SUM(CANTIDAD) AS TOTAL FROM DETALLE_FACTURA WHERE IDPRODUCTO = 2;

SELECT COUNT(*) AS PRODUCTOS FROM PRODUCTO;
SELECT COUNT(*) AS PRODUCTOS FROM PRODUCTO WHERE IDCATEGORIA = 2;

SELECT COUNT(DISTINCT(IDCATEGORIA)) FROM PRODUCTO; 


-- Promedio, máximo y mínimo

SELECT AVG(PRECIOUNITARIO) FROM PRODUCTO;
SELECT MIN(PRECIOUNITARIO) FROM PRODUCTO;
SELECT MAX(PRECIOUNITARIO) FROM PRODUCTO;

-- Devuelve el valor más pequeño de una lista
SELECT LEAST(3, 5, 7, 9, 11) AS RESULTADO;

-- Agrupación

SELECT * FROM CLIENTE;
SELECT PAIS FROM CLIENTE;
SELECT PAIS FROM CLIENTE GROUP BY PAIS;

SELECT * FROM DETALLE_FACTURA;

SELECT IDFACTURA, SUM(PRECIOUNITARIO * CANTIDAD) AS TOTAL FROM DETALLE_FACTURA; -- Solo devuelve la primera factura --
SELECT IDFACTURA, SUM(PRECIOUNITARIO * CANTIDAD) AS TOTAL FROM DETALLE_FACTURA GROUP BY IDFACTURA; -- Nos devuelve todas las facturas con sus respectivos totales --

SELECT IDCLIENTE, COUNT(IDFACTURA) AS FACTURAS FROM FACTURA GROUP BY IDCLIENTE;

SELECT IDCLIENTE, COUNT(IDFACTURA) AS FACTURAS FROM FACTURA GROUP BY IDCLIENTE WITH ROLLUP;

SELECT IF (GROUPING(IDCLIENTE), 'TOTAL', IDCLIENTE) AS CLIENTE, COUNT(IDFACTURA) AS FACTURAS FROM FACTURA GROUP BY IDCLIENTE WITH ROLLUP;

-- Veamos los productos agrupados de cada categoría
SELECT IDCATEGORIA, GROUP_CONCAT(IDPRODUCTO) AS PRODUCTO FROM PRODUCTO GROUP BY IDCATEGORIA;

-- Vamos a utilizar HAVING para ver facturas cuyo importe sea mayor que un cierto valor
SELECT IDFACTURA, SUM(PRECIOUNITARIO * CANTIDAD) AS TOTAL FROM DETALLE_FACTURA GROUP BY IDFACTURA HAVING TOTAL > 14;

-- Ordenamiento de datos

SELECT NOMBRE, APELLIDO FROM CLIENTE ORDER BY APELLIDO;
SELECT NOMBRE, APELLIDO FROM CLIENTE ORDER BY APELLIDO ASC;
SELECT NOMBRE, APELLIDO FROM CLIENTE ORDER BY APELLIDO DESC;
SELECT NOMBRE, APELLIDO FROM CLIENTE ORDER BY RAND();

SELECT * FROM EMPLEADO;
SELECT * FROM EMPLEADO ORDER BY FECHAINGRESO LIMIT 2;

SELECT * FROM PRODUCTO;
SELECT * FROM PRODUCTO ORDER BY IDPRODUCTO LIMIT 3, 4; -- Muestra a partir del ID = 3 y muestra 4 registros.
SELECT * FROM PRODUCTO ORDER BY IDPRODUCTO LIMIT 4 OFFSET 3; -- OFFSET a partir de cuál registro se muestra.

-- UNIONES DE TABLAS ---

SELECT CATEGORIA.NOMBRE AS CATEGORIA, PRODUCTO.NOMBRE AS PRODUCTO FROM PRODUCTO 
INNER JOIN CATEGORIA ON CATEGORIA.IDCATEGORIA = PRODUCTO.IDCATEGORIA;

SELECT FACTURA.IDFACTURA AS FACTURA, CLIENTE.NOMBRE AS CLIENTE, EMPLEADO.NOMBRE AS EMPLEADO FROM FACTURA 
INNER JOIN CLIENTE ON CLIENTE.IDCLIENTE = FACTURA.IDCLIENTE
INNER JOIN EMPLEADO ON EMPLEADO.IDEMPLEADO = FACTURA.IDEMPLEADO 
ORDER BY FACTURA.IDFACTURA;

-- Un ejemplo con CROSS JOIN, une las dos tablas
SELECT * FROM CLIENTE CROSS JOIN FACTURA;

-- Un ejemplo con LEFT JOIN ---
-- Se devuelven las filas de la primera tabla aunque no cumplan con la condición, si no se encuentra dato en la segunda tabla se devuelve NULL
SELECT CLIENTE.NOMBRE AS CLIENTE, FACTURA.IDFACTURA AS FACTURA FROM CLIENTE
LEFT JOIN FACTURA ON CLIENTE.IDCLIENTE = FACTURA.IDCLIENTE
ORDER BY CLIENTE.NOMBRE;

-- Podemos buscar los clientes que no tienen una factura asociada.
SELECT CLIENTE.NOMBRE AS CLIENTE, FACTURA.IDFACTURA AS FACTURA FROM CLIENTE
LEFT JOIN FACTURA ON CLIENTE.IDCLIENTE = FACTURA.IDCLIENTE
WHERE FACTURA.IDFACTURA IS NULL
ORDER BY CLIENTE.NOMBRE;

-- Podemos asociar las facturas y los productos asociados a dicha factura.
SELECT FACTURA.IDFACTURA AS FACTURA, IDPRODUCTO AS PRODUCTO FROM FACTURA
LEFT JOIN DETALLE_FACTURA ON FACTURA.IDFACTURA = DETALLE_FACTURA.IDFACTURA;

SELECT FACTURA.IDFACTURA AS FACTURA, IDPRODUCTO AS PRODUCTO FROM FACTURA
LEFT JOIN DETALLE_FACTURA ON FACTURA.IDFACTURA = DETALLE_FACTURA.IDFACTURA AND FACTURA.IDFACTURA = 1 ORDER BY FACTURA.IDFACTURA;

SELECT FACTURA.IDFACTURA AS FACTURA, CLIENTE.NOMBRE AS CLIENTE, IDPRODUCTO AS PRODUCTO FROM CLIENTE 
LEFT JOIN FACTURA ON FACTURA.IDCLIENTE = CLIENTE.IDCLIENTE
LEFT JOIN DETALLE_FACTURA ON DETALLE_FACTURA.IDFACTURA = FACTURA.IDFACTURA
ORDER BY CLIENTE.NOMBRE, FACTURA ASC; -- Para los clientes que no tienen factura asociada nos devolverá NULL


-- Un ejemplo con RIGHT JOIN ---

SELECT CLIENTE.NOMBRE AS CLIENTE, FACTURA.IDFACTURA AS FACTURA FROM CLIENTE 
RIGHT JOIN FACTURA ON FACTURA.IDCLIENTE = CLIENTE.IDCLIENTE
ORDER BY FACTURA.IDFACTURA;  -- Se devuelven los valores de la segunda tabla incluso cuando no cumplan la condición.alter


SELECT FACTURA.IDFACTURA AS FACTURA, EMPLEADO.NOMBRE AS EMPLEADO FROM FACTURA
RIGHT JOIN EMPLEADO ON FACTURA.IDEMPLEADO = EMPLEADO.IDEMPLEADO 
ORDER BY FACTURA.IDFACTURA;

SELECT DETALLE_FACTURA.IDFACTURA AS FACTURA, PRODUCTO.NOMBRE AS PRODUCTO, DETALLE_FACTURA.CANTIDAD AS CANTIDAD FROM DETALLE_FACTURA
RIGHT JOIN PRODUCTO ON DETALLE_FACTURA.IDPRODUCTO = PRODUCTO.IDPRODUCTO
ORDER BY FACTURA; -- Hay productos que todavía no hemos vendido por eso devuelve NULL ---

-- Un ejemplo NATURAL JOIN ---

SELECT * FROM FACTURA NATURAL JOIN DETALLE_FACTURA;
SELECT * FROM FACTURA NATURAL JOIN CLIENTE ORDER BY IDCLIENTE;

-- AQUÍ -- MARCADOR---

-- Un ejemplo ON y USING ---

SELECT CLIENTE.IDCLIENTE AS ID, CLIENTE.NOMBRE AS NOMBRE, FACTURA.IDFACTURA AS FACTURA FROM CLIENTE
LEFT JOIN FACTURA USING(IDCLIENTE);  -- USING se utiliza para la unión y se pasa el nombre de columna que tienen en común ---alter

SELECT CLIENTE.IDCLIENTE AS ID, CLIENTE.NOMBRE AS NOMBRE, FACTURA.IDFACTURA AS FACTURA FROM CLIENTE
LEFT JOIN FACTURA USING(IDCLIENTE) WHERE IDCLIENTE = 1;  -- USING se utiliza para la unión y se pasa el nombre de columna que tienen en común ---

SELECT CLIENTE.IDCLIENTE AS ID, CLIENTE.NOMBRE AS NOMBRE, FACTURA.IDFACTURA AS FACTURA FROM CLIENTE
LEFT JOIN FACTURA ON FACTURA.IDCLIENTE = CLIENTE.IDCLIENTE;  -- ON se utiliza para la unión y se pasa el atributo de la relación entre ambas tablas ---

SELECT CLIENTE.IDCLIENTE AS ID, CLIENTE.NOMBRE AS NOMBRE, FACTURA.IDFACTURA AS FACTURA FROM CLIENTE
LEFT JOIN FACTURA ON FACTURA.IDCLIENTE = CLIENTE.IDCLIENTE AND CLIENTE.IDCLIENTE = 1;  -- ON se utiliza para la unión y se pasa el atributo de la relación entre ambas tablas ---
-- Probar esta misma sentencia utilizando LEFT, RIGHT, INNER ---

-- EXPRESIONES AVANZADAS ----

-- CASE ---
SELECT 
	CASE 1
    WHEN 1 THEN 'UNO'
    WHEN 2 THEN 'DOS'
    ELSE 'OTRO NÚMERO'
END AS VALOR;

SELECT * FROM DETALLE_FACTURA;

SELECT IDFACTURA, IDPRODUCTO, 
CASE 
	WHEN CANTIDAD > 2 THEN 'Más de dos productos vendidos'
    WHEN CANTIDAD = 2 THEN 'Dos productos vendidos'
    ELSE 'Menos de dos productos vendidos'
END AS CANTIDAD
FROM DETALLE_FACTURA;

SELECT NOMBRE,
CASE 
	WHEN EMAIL IS NULL THEN 'No tiene email registrado'
	ELSE EMAIL
END AS EMAIL, 
PAIS 
FROM CLIENTE;


-- IF ---

SELECT IF (1 < 2, TRUE, FALSE) AS RESULTADO;

SELECT IF (1 > 2, TRUE, FALSE) AS RESULTADO;

-- Si la cantidad > 1 entonces devuelve cantidad * preciounitario; en caso contrario devuelve preciounitario ---
SELECT IDPRODUCTO, IF (CANTIDAD > 1, CANTIDAD * PRECIOUNITARIO, PRECIOUNITARIO) AS TOTAL FROM DETALLE_FACTURA;

SELECT NOMBRE,
IF(FECHAINGRESO < '2016-12-31', CONCAT(IDEMPLEADO, '-16'),
	IF(FECHAINGRESO < '2017-12-31', CONCAT(IDEMPLEADO, '-17'),
		IF(FECHAINGRESO < '2018-12-31', CONCAT(IDEMPLEADO, '-18'),
			CONCAT(IDEMPLEADO, '-19')
		)
	)
) AS CODIGO
FROM EMPLEADO;

-- IFNULL / NULLIF ---

SELECT IFNULL(NULL, "TEXTO") AS RESULTADO;

SELECT NOMBRE, IFNULL(EMAIL, TELEFONO) AS CONTACTO FROM CLIENTE; -- En el caso de no disponer de email, nos devuelve el teléfono ---

SELECT NOMBRE, IFNULL((SELECT EMAIL FROM CLIENTE WHERE IDCLIENTE = '14'), 'No tiene email registrado') AS EMAIL FROM CLIENTE WHERE IDCLIENTE = '14';

SELECT NULLIF(1, 1); -- NULLIF compara dos expresiones si son iguales devuelve NULL, en caso contrario devuelve el primer valor pasado por parámetro.
SELECT NULLIF(1, 2);

SELECT NULLIF(
(SELECT PRECIOUNITARIO FROM PRODUCTO WHERE IDPRODUCTO = 1), 
(SELECT PRECIOUNITARIO FROM PRODUCTO WHERE IDPRODUCTO = 2)); 


-- SUBQUERIES ---

SELECT IDEMPLEADO, NOMBRE, SALARIO FROM EMPLEADO WHERE SALARIO > (SELECT AVG(SALARIO) FROM EMPLEADO);
SELECT AVG(SALARIO) FROM EMPLEADO;

SELECT NOMBRE, APELLIDO, IDDEPARTAMENTO FROM EMPLEADO WHERE IDDEPARTAMENTO NOT IN (SELECT IDDEPARTAMENTO FROM DEPARTAMENTO WHERE NOMBRE LIKE "%general%");
SELECT * FROM DEPARTAMENTO;

SELECT IDCLIENTE, IDFACTURA FROM FACTURA WHERE IDCLIENTE IN (SELECT IDCLIENTE FROM CLIENTE WHERE PAIS = 'Canadá' OR PAIS = 'Brasil');
SELECT IDCLIENTE FROM CLIENTE WHERE PAIS = 'Canadá' OR PAIS = 'Brasil';
SELECT * FROM CLIENTE;
SELECT * FROM FACTURA; -- Pedro con el ID 12 no tiene facturas ---

SELECT * FROM FACTURA WHERE IDCLIENTE = (SELECT IDCLIENTE FROM CLIENTE WHERE NOMBRE = 'Jordi');

SELECT * FROM PRODUCTO WHERE PRECIOUNITARIO <= (SELECT AVG(PRECIOUNITARIO) FROM PRODUCTO WHERE IDCATEGORIA = 5) AND IDCATEGORIA = 5;
SELECT AVG(PRECIOUNITARIO) FROM PRODUCTO WHERE IDCATEGORIA = 5;
SELECT * FROM PRODUCTO;

SELECT IDPRODUCTO, NOMBRE FROM PRODUCTO WHERE IDPRODUCTO = ANY (SELECT IDPRODUCTO FROM DETALLE_FACTURA);
SELECT * FROM PRODUCTO; -- Arroz y Ciruela no han sido vendidos --- 

SELECT * FROM CATEGORIA;
SELECT IDFACTURA, IDPRODUCTO, (CANTIDAD * PRECIOUNITARIO) AS TOTAL FROM DETALLE_FACTURA WHERE IDPRODUCTO = SOME (SELECT IDPRODUCTO FROM PRODUCTO WHERE IDCATEGORIA IN(1,2));
SELECT IDPRODUCTO FROM PRODUCTO WHERE IDCATEGORIA IN(1,2);
SELECT IDFACTURA, IDPRODUCTO, (CANTIDAD * PRECIOUNITARIO) AS TOTAL FROM DETALLE_FACTURA;
SELECT * FROM PRODUCTO; -- El producto 12 y 14 no han sido vendidos---

SELECT IDCATEGORIA, AVG(PRECIOUNITARIO) AS PRECIOUNITARIO FROM PRODUCTO GROUP BY IDCATEGORIA HAVING AVG(PRECIOUNITARIO) >= ALL (SELECT AVG(PRECIOUNITARIO) FROM PRODUCTO GROUP BY IDCATEGORIA);
SELECT IDCATEGORIA, AVG(PRECIOUNITARIO) AS PRECIOUNITARIO FROM PRODUCTO GROUP BY IDCATEGORIA;
SELECT AVG(PRECIOUNITARIO) FROM PRODUCTO GROUP BY IDCATEGORIA; -- La categoría 4 es la que tiene el promedio de precio más alto ---

SELECT * FROM FACTURA WHERE IDCLIENTE IN (SELECT IDCLIENTE FROM CLIENTE WHERE PAIS IN ('Honduras', 'Estados Unidos', 'Colombia')) ORDER BY IDFACTURA;
SELECT IDCLIENTE FROM CLIENTE WHERE PAIS IN ('Honduras', 'Estados Unidos', 'Colombia');

SELECT * FROM PRODUCTO WHERE IDCATEGORIA NOT IN (SELECT IDCATEGORIA FROM CATEGORIA WHERE DESCRIPCION LIKE '%maiz%' OR DESCRIPCION LIKE '%queso%');
SELECT IDCATEGORIA FROM CATEGORIA WHERE DESCRIPCION LIKE '%maiz%' OR DESCRIPCION LIKE '%queso%';

-- EXISTS se utiliza para determinar si hay datos o no en una lista ---
SELECT IDCLIENTE, NOMBRE FROM CLIENTE WHERE EXISTS (SELECT * FROM FACTURA WHERE FACTURA.IDCLIENTE = CLIENTE.IDCLIENTE); -- El id del cliente 2 no está, NO TIENE FACTURAS ---
SELECT * FROM FACTURA;

SELECT P.IDPRODUCTO, P.NOMBRE AS PRODUCTO, C.NOMBRE AS CATEGORIA FROM PRODUCTO AS P
LEFT JOIN CATEGORIA AS C USING (IDCATEGORIA)
WHERE NOT EXISTS (SELECT * FROM DETALLE_FACTURA WHERE DETALLE_FACTURA.IDPRODUCTO = P.IDPRODUCTO); -- Los únicos productos que no han tenido ventas son arroz y ciruela ---
SELECT * FROM DETALLE_FACTURA, PRODUCTO AS P WHERE DETALLE_FACTURA.IDPRODUCTO = P.IDPRODUCTO;

CREATE TABLE ASOCIACION (
IDASOCIACION INT NOT NULL AUTO_INCREMENT,
IDEMPLEADO INT NOT NULL,
NOMBRE VARCHAR(45) NULL,
APELLIDO VARCHAR(45) NULL,
FECHAINGRESO DATE NULL,
EMAIL VARCHAR(45) NULL,
TELEFONO VARCHAR(45) NULL,
PRIMARY KEY (IDASOCIACION))
DEFAULT CHARACTER SET = utf8mb4;


-- INSERT INTO SELECT ----
ALTER TABLE ASOCIACION ADD INDEX `FK_EMP_ASO_idx` (`IDEMPLEADO` ASC) VISIBLE;
ALTER TABLE ASOCIACION ADD CONSTRAINT `FK_EMP_ASO` FOREIGN KEY (IDEMPLEADO) REFERENCES EMPLEADO (IDEMPLEADO) ON DELETE RESTRICT ON UPDATE CASCADE;

INSERT INTO ASOCIACION (IDEMPLEADO, NOMBRE, APELLIDO, FECHAINGRESO, EMAIL, TELEFONO) 
SELECT IDEMPLEADO, NOMBRE, APELLIDO, FECHAINGRESO, EMAIL, TELEFONO FROM EMPLEADO WHERE FECHAINGRESO < '2019-01-01';

SELECT * FROM ASOCIACION;

-- Podemos considerar la UNION entre dos tablas, para ello es imprescindible que los campos de unión sean los mismos (en número), además incluimos el atributo Tipo Usuario para distinguir en la unión ---
SELECT IDEMPLEADO AS IDEMPLEADO, NOMBRE, APELLIDO, IFNULL(EMAIL, TELEFONO) AS CONTACTO, 'Empleado' AS 'Tipo Usuario' FROM EMPLEADO 
UNION 
SELECT IDCLIENTE AS ID, NOMBRE, APELLIDO, IFNULL(EMAIL, TELEFONO) AS CONTACTO, 'Cliente' AS 'Tipo Usuario' FROM CLIENTE;

